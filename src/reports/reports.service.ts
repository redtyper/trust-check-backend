import { Injectable, BadRequestException } from '@nestjs/common';
import { CreateReportDto } from './dto/create-report.dto';
import { PrismaService } from '../prisma.service';
import * as fs from 'fs';
import * as path from 'path';
import * as express from 'express';

@Injectable()
export class ReportsService {
  private readonly uploadsDir = path.join(process.cwd(), 'uploads/screenshots');

  constructor(private readonly prisma: PrismaService) {
    if (!fs.existsSync(this.uploadsDir)) {
      fs.mkdirSync(this.uploadsDir, { recursive: true });
    }
  }

  async create(dto: CreateReportDto, userId: number, ip: string) {
    const data: any = {
      userId,
      rating: dto.rating,
      reason: dto.reason,
      comment: dto.comment,
      ipAddress: ip,
      // Pola wspólne (OSINT)
      reportedEmail: dto.reportedEmail,
      facebookLink: dto.facebookLink,
      bankAccount: dto.bankAccount,
      // Zdjęcia
      screenshotUrl: dto.screenshotUrl,
      screenshotPath: dto.screenshotPath,
      // Metadane
      isAutoGenerated: dto.isAutoGenerated || false,
      sourceUrl: dto.sourceUrl,
    };

    // --- ŚCIEŻKA 1: FIRMA (COMPANY) ---
    if (dto.targetType === 'COMPANY') {
        const nip = dto.targetValue;
        if (!/^[0-9]{10}$/.test(nip)) {
           throw new BadRequestException('NIP musi mieć 10 cyfr');
        }

        // 1. Upsert Firmy
        await this.prisma.company.upsert({
            where: { nip },
            update: {
                // Opcjonalnie aktualizujemy nazwę, jeśli podano nową, ale bezpieczniej zostawić starą
            },
            create: {
                nip,
                name: dto.scammerName || 'Nieznana Firma', // Fallback name
                statusVat: 'Nieznany',
                trustScore: 50,
                riskLevel: 'Nieznany'
            }
        });

        data.companyNip = nip;
        
        // Jeśli firma ma podany telefon, dodajemy go do tabeli PhoneNumber i wiążemy
        if (dto.phoneNumber) {
             await this.prisma.phoneNumber.upsert({
                 where: { number: dto.phoneNumber },
                 update: { companyNip: nip }, // Wiążemy numer z firmą
                 create: { number: dto.phoneNumber, countryCode: 'PL', companyNip: nip }
             });
             data.phoneNumber = dto.phoneNumber; // Wiążemy raport też z telefonem
        }
    } 
    
    // --- ŚCIEŻKA 2: OSOBA (PERSON) ---
    else {
        // Person Name to albo scammerName, albo targetValue
        const name = dto.scammerName || dto.targetValue || 'Nieznany';
        
        // 1. Szukamy lub tworzymy osobę
        // Używamy findFirst + update/create zamiast upsert, bo name nie jest unikalne (chyba że dodałeś @unique)
        const existingPerson = await this.prisma.person.findFirst({
            where: { name: name }
        });

        let personId;

        if (existingPerson) {
            const updated = await this.prisma.person.update({
                where: { id: existingPerson.id },
                data: {
                    email: dto.reportedEmail || existingPerson.email,
                    bankAccount: dto.bankAccount || existingPerson.bankAccount,
                    phone: dto.phoneNumber || existingPerson.phone
                }
            });
            personId = updated.id;
        } else {
            const created = await this.prisma.person.create({
                data: {
                    name: name,
                    email: dto.reportedEmail,
                    bankAccount: dto.bankAccount,
                    phone: dto.phoneNumber
                }
            });
            personId = created.id;
        }

        data.personId = personId;
        data.scammerName = name; // Zapisujemy też w raporcie jako snapshot

        // 2. Jeśli podano telefon, zapisujemy go TEŻ w tabeli PhoneNumber i wiążemy raport
        // Dzięki temu wyszukiwanie "500600700" znajdzie ten raport
        if (dto.phoneNumber) {
             await this.prisma.phoneNumber.upsert({
                 where: { number: dto.phoneNumber },
                 update: {},
                 create: { number: dto.phoneNumber, countryCode: 'PL', trustScore: 50 }
             });
             data.phoneNumber = dto.phoneNumber;
        }
    }

    // TWORZENIE RAPORTU
    return this.prisma.report.create({ data });
  }

  async uploadScreenshot(file: Express.Multer.File): Promise<string> {
    if (!file) throw new BadRequestException('Brak pliku');
    const allowedMimes = ['image/jpeg', 'image/png', 'image/webp', 'image/gif'];
    if (!allowedMimes.includes(file.mimetype!)) throw new BadRequestException('Zły format pliku');
    if (file.size! > 5 * 1024 * 1024) throw new BadRequestException('Plik > 5MB');
    
    const timestamp = Date.now();
    const ext = file.mimetype!.split('/')[1];
    const filename = `screenshot${timestamp}${Math.random().toString(36).substr(2, 9)}.${ext}`;
    const filepath = path.join(this.uploadsDir, filename);
    
    fs.writeFileSync(filepath, file.buffer!);
    return `uploads/screenshots/${filename}`;
  }

  // Statystyki - uproszczone
  async getStatsForTarget(targetValue: string) {
    const isNip = /^[0-9]{10}$/.test(targetValue);
    const isPhone = /^[0-9+]{9,}$/.test(targetValue.replace(/\s/g, ''));
    
    let whereCondition: any = {};
    
    if (isNip) {
        whereCondition = { companyNip: targetValue };
    } else if (isPhone) {
        // Szukamy raportów gdzie phoneNumber jest taki SAMO
        // LUB gdzie osoba ma taki numer telefonu
        whereCondition = {
            OR: [
                { phoneNumber: targetValue },
                { person: { phone: targetValue } }
            ]
        };
    } else {
        // Osoba po nazwie
        whereCondition = {
            OR: [
                { person: { name: { contains: targetValue, mode: 'insensitive' } } },
                { scammerName: { contains: targetValue, mode: 'insensitive' } }
            ]
        };
    }

    const reports = await this.prisma.report.findMany({
      where: whereCondition,
      orderBy: { createdAt: 'desc' },
      include: { user: { select: { email: true } }, person: true },
    });

    const negative = reports.filter((r) => r.rating <= 2).length;
    const positive = reports.filter((r) => r.rating >= 4).length;
    
    const entries = reports.map(r => ({
        ...r,
        phoneNumber: r.phoneNumber,
        screenshotUrl: r.screenshotUrl,
        screenshotPath: r.screenshotPath
    }));

    return { total: reports.length, negative, positive, entries };
  }
  
  // GetLatest - bez zmian, bo działa na gotowych danych
  async getLatestGlobal(limit: number = 6) {
    const reports = await this.prisma.report.findMany({
      take: limit,
      orderBy: { createdAt: 'desc' },
      include: {
        phone: { select: { number: true, trustScore: true } },
        company: { select: { nip: true, name: true, trustScore: true } },
        person: { select: { id: true, name: true } },
      },
    });
    return reports.map((r) => {
      let targetValue = 'Nieznany';
      let targetType = 'OTHER';
      if (r.companyNip) {
          targetValue = r.companyNip;
          targetType = 'COMPANY';
      } else if (r.personId) {
          targetValue = r.person?.name || r.scammerName || 'Osoba';
          targetType = 'PERSON';
      } else if (r.phoneNumber) {
          targetValue = r.phoneNumber;
          targetType = 'PERSON'; // Telefon traktujemy jako osobę jeśli nie ma NIPu
      }

      return {
        id: r.id,
        targetValue,
        targetType,
        rating: r.rating,
        reason: r.reason,
        comment: r.comment,
        date: r.createdAt,
        screenshotPath: r.screenshotPath,
        screenshotUrl: r.screenshotUrl
      };
    });
  }
}
