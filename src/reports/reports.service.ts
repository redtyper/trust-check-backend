import { Injectable, BadRequestException, Logger } from '@nestjs/common';
import { CreateReportDto } from './dto/create-report.dto';
import { PrismaService } from '../prisma.service';
import * as fs from 'fs';
import * as path from 'path';

// Constants
const UPLOADS_DIR = path.join(process.cwd(), 'uploads/screenshots');
const ALLOWED_MIME_TYPES = ['image/jpeg', 'image/png', 'image/webp', 'image/gif'];
const MAX_FILE_SIZE = 5 * 1024 * 1024; // 5MB
const COUNTRY_CODE = 'PL';
const DEFAULT_COMPANY_NAME = 'Unknown Company';
const DEFAULT_PERSON_NAME = 'Unknown Person';

// Interfaces
interface CreateReportData {
  userId: number;
  rating: number;
  reason: string;
  comment?: string;
  ipAddress: string;
  reportedEmail?: string;
  facebookLink?: string;
  bankAccount?: string;
  screenshotUrl?: string;
  screenshotPath?: string;
  isAutoGenerated?: boolean;
  sourceUrl?: string;
  companyNip?: string;
  personId?: number;
  phoneNumber?: string;
  scammerName?: string;
}

interface ReportStatistics {
  total: number;
  negative: number;
  positive: number;
  entries: any[];
}

interface LatestReportResponse {
  id: number;
  targetValue: string;
  targetType: string;
  rating: number;
  reason: string;
  comment?: string;
  date: Date;
  screenshotPath?: string;
  screenshotUrl?: string;
  phoneNumber?: string;
  bankAccount?: string;
}

@Injectable()
export class ReportsService {
  private readonly logger = new Logger(ReportsService.name);

  constructor(private readonly prisma: PrismaService) {
    this.initializeUploadsDir();
  }

  /**
   * Initialize uploads directory
   */
  private initializeUploadsDir(): void {
    if (!fs.existsSync(UPLOADS_DIR)) {
      fs.mkdirSync(UPLOADS_DIR, { recursive: true });
      this.logger.log(`Created uploads directory: ${UPLOADS_DIR}`);
    }
  }

  /**
   * Create a new report
   * @param dto - Report data
   * @param userId - User who created the report
   * @param ip - IP address of the requester
   * @returns Created report
   */
  async create(dto: CreateReportDto, userId: number, ip: string): Promise<any> {
    try {
      this.validateReport(dto);

      const baseData: CreateReportData = {
        userId,
        rating: dto.rating,
        reason: dto.reason,
        comment: dto.comment,
        ipAddress: ip,
        reportedEmail: dto.reportedEmail,
        facebookLink: dto.facebookLink,
        bankAccount: dto.bankAccount,
        screenshotUrl: dto.screenshotUrl,
        screenshotPath: dto.screenshotPath,
        isAutoGenerated: dto.isAutoGenerated || false,
        sourceUrl: dto.sourceUrl,
      };

      let reportData: CreateReportData;

      if (dto.targetType === 'COMPANY') {
        reportData = await this.createCompanyReport(baseData, dto);
      } else {
        reportData = await this.createPersonReport(baseData, dto);
      }

      const report = await this.prisma.report.create({ data: reportData as any });
      this.logger.log(`Report created: ${report.id} by user ${userId}`);
      return report;
    } catch (error) {
      this.logger.error(`Failed to create report: ${error.message}`);
      throw error;
    }
  }

  /**
   * Create company report
   */
  private async createCompanyReport(
    baseData: CreateReportData,
    dto: CreateReportDto,
  ): Promise<CreateReportData> {
    const nip = dto.targetValue;
    
    if (!/^\d{10}$/.test(nip)) {
      throw new BadRequestException('NIP must be exactly 10 digits');
    }

    // Upsert company
    await this.prisma.company.upsert({
      where: { nip },
      update: {},
      create: {
        nip,
        name: dto.scammerName || DEFAULT_COMPANY_NAME,
        statusVat: 'Unknown',
        trustScore: 50,
        riskLevel: 'Unknown',
      },
    });

    baseData.companyNip = nip;

    // Link phone number if provided
    if (dto.phoneNumber) {
      await this.linkPhoneToCompany(nip, dto.phoneNumber);
      baseData.phoneNumber = dto.phoneNumber;
    }

    return baseData;
  }

  /**
   * Create person report
   */
  private async createPersonReport(
    baseData: CreateReportData,
    dto: CreateReportDto,
  ): Promise<CreateReportData> {
    const name = dto.scammerName || dto.targetValue || DEFAULT_PERSON_NAME;

    // Find or create person
    const existingPerson = await this.prisma.person.findFirst({
      where: { name },
    });

    let personId: number;

    if (existingPerson) {
      const updated = await this.prisma.person.update({
        where: { id: existingPerson.id },
        data: {
          email: dto.reportedEmail || existingPerson.email,
          bankAccount: dto.bankAccount || existingPerson.bankAccount,
          phone: dto.phoneNumber || existingPerson.phone,
        },
      });
      personId = updated.id;
    } else {
      const created = await this.prisma.person.create({
        data: {
          name,
          email: dto.reportedEmail,
          bankAccount: dto.bankAccount,
          phone: dto.phoneNumber,
        },
      });
      personId = created.id;
    }

    baseData.personId = personId;
    baseData.scammerName = name;

    // Link phone number if provided
    if (dto.phoneNumber) {
      await this.createPhoneNumberRecord(dto.phoneNumber);
      baseData.phoneNumber = dto.phoneNumber;
    }

    return baseData;
  }

  /**
   * Link phone number to company
   */
  private async linkPhoneToCompany(
    companyNip: string,
    phoneNumber: string,
  ): Promise<void> {
    await this.prisma.phoneNumber.upsert({
      where: { number: phoneNumber },
      update: { companyNip },
      create: {
        number: phoneNumber,
        countryCode: COUNTRY_CODE,
        companyNip,
      },
    });
  }

  /**
   * Create phone number record
   */
  private async createPhoneNumberRecord(phoneNumber: string): Promise<void> {
    await this.prisma.phoneNumber.upsert({
      where: { number: phoneNumber },
      update: {},
      create: {
        number: phoneNumber,
        countryCode: COUNTRY_CODE,
        trustScore: 50,
      },
    });
  }

  /**
   * Validate report data
   */
  private validateReport(dto: CreateReportDto): void {
    if (!dto.rating || dto.rating < 1 || dto.rating > 5) {
      throw new BadRequestException('Rating must be between 1 and 5');
    }
    if (!dto.reason || dto.reason.trim().length === 0) {
      throw new BadRequestException('Reason is required');
    }
    if (!dto.targetValue || dto.targetValue.trim().length === 0) {
      throw new BadRequestException('Target value is required');
    }
  }

  /**
   * Upload screenshot file
   * @param file - Multer file object
   * @returns Path to the uploaded file
   */
  async uploadScreenshot(file: Express.Multer.File): Promise<string> {
    if (!file) {
      throw new BadRequestException('File is required');
    }

    if (!ALLOWED_MIME_TYPES.includes(file.mimetype)) {
      throw new BadRequestException(
        `Invalid file format. Allowed types: ${ALLOWED_MIME_TYPES.join(', ')}`,
      );
    }

    if (file.size > MAX_FILE_SIZE) {
      throw new BadRequestException(
        `File size must not exceed ${MAX_FILE_SIZE / 1024 / 1024}MB`,
      );
    }

    const timestamp = Date.now();
    const ext = file.mimetype.split('/')[1];
    const randomSuffix = Math.random().toString(36).substring(2, 11);
    const filename = `screenshot_${timestamp}_${randomSuffix}.${ext}`;
    const filepath = path.join(UPLOADS_DIR, filename);

    try {
      fs.writeFileSync(filepath, file.buffer);
      this.logger.log(`Screenshot uploaded: ${filename}`);
      return `uploads/screenshots/${filename}`;
    } catch (error) {
      this.logger.error(`Failed to upload screenshot: ${error.message}`);
      throw new BadRequestException('Failed to save file');
    }
  }

  /**
   * Get statistics for a target (company, person, or phone)
   * @param targetValue - NIP, person name, or phone number
   * @returns Statistics object
   */
  async getStatsForTarget(targetValue: string): Promise<ReportStatistics> {
    const isNip = /^\d{10}$/.test(targetValue);
    const isPhone = /^[0-9+\s\-()]+$/.test(targetValue) && targetValue.length >= 9;

    let whereCondition: any = {};

    if (isNip) {
      whereCondition = { companyNip: targetValue };
    } else if (isPhone) {
      whereCondition = {
        OR: [
          { phoneNumber: targetValue },
          { person: { phone: targetValue } },
        ],
      };
    } else {
      // Search by person name
      whereCondition = {
        OR: [
          { person: { name: { contains: targetValue, mode: 'insensitive' } } },
          { scammerName: { contains: targetValue, mode: 'insensitive' } },
        ],
      };
    }

    const reports = await this.prisma.report.findMany({
      where: whereCondition,
      orderBy: { createdAt: 'desc' },
      include: {
        user: { select: { email: true } },
        person: true,
      },
    });

    const negative = reports.filter((r) => r.rating <= 2).length;
    const positive = reports.filter((r) => r.rating >= 4).length;

    const entries = reports.map((r) => ({
      ...r,
      phoneNumber: r.phoneNumber,
      screenshotUrl: r.screenshotUrl,
      screenshotPath: r.screenshotPath,
    }));

    return { total: reports.length, negative, positive, entries };
  }

  /**
   * Get latest global reports
   * @param limit - Maximum number of reports to return
   * @returns Array of latest reports
   */
  async getLatestGlobal(limit: number = 6): Promise<LatestReportResponse[]> {
    const reports = await this.prisma.report.findMany({
      take: limit,
      orderBy: { createdAt: 'desc' },
      include: {
        phoneNumber: { select: { number: true, trustScore: true } },
        company: { select: { nip: true, name: true, trustScore: true } },
        person: { select: { id: true, name: true } },
      },
    });

    return reports.map((r) => this.mapReportToResponse(r));
  }

  /**
   * Map report to response format
   */
  private mapReportToResponse(r: any): LatestReportResponse {
    let targetValue = 'Unknown';
    let targetType = 'OTHER';

    if (r.companyNip) {
      targetValue = r.companyNip;
      targetType = 'COMPANY';
    } else if (r.personId) {
      targetValue = r.person?.name || r.scammerName || DEFAULT_PERSON_NAME;
      targetType = 'PERSON';
    } else if (r.phoneNumber) {
      targetValue = r.phoneNumber;
      targetType = 'PERSON';
    }

    return {
      id: r.id,
      targetValue,
      targetType,
      rating: r.rating,
      reason: r.reason,
      comment: r.comment,
      date: r.createdAt,
      screenshotPath: r.screenshotPath,
      screenshotUrl: r.screenshotUrl,
      phoneNumber: r.phoneNumber,
      bankAccount: r.bankAccount,
    };
  }
}
